# -*- coding: utf-8 -*-
"""testfun3_ATO_HotStart

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1l7LCSr_NUXDwGw8rMiHlAzC8BQ2XdlqD

**Assemble-to-Order Simulator**

code ported from

[SimOpt Library (matlab)](http://simopt.org/wiki/index.php?title=Assemble_to_order)

Requires:
 - numpy
"""

# @title Source code, make the function
import numpy as np


class ATO_HongNelson:
    def __init__(self, simreps=5):

        self.seed = 1

        self.NumComponentType = 8  # numebr of products
        self.NumCustomerType = 5  # number of customer types

        self.xmin = np.zeros([self.NumComponentType])
        self.xmax = 20 * np.ones([self.NumComponentType])

        self.simreps = simreps

        self.ProTimeMean = np.asarray([0.15, 0.4, 0.25, 0.15, 0.25, 0.08, 0.13, 0.4])

        self.ProTimeStd = 0.15 * self.ProTimeMean
        self.Profit = np.linspace(1, self.NumComponentType, self.NumComponentType)
        self.HoldingCost = 2 * np.ones([self.NumComponentType])

        self.ArrivalRate = 12.0  # assume Possion arrival
        self.iArrivalRate = 1.0 / self.ArrivalRate

        self.WarmUp = 20
        self.TotalTime = 70

        self.CustomerProb = np.asarray([0.3, 0.25, 0.2, 0.15, 0.1])  # prob. of each customer

        self.KeyComponent = np.asarray(
            [
                [1, 0, 0, 1, 0, 1, 0, 0],
                [1, 0, 0, 0, 1, 1, 0, 0],
                [0, 1, 0, 1, 0, 1, 0, 0],
                [0, 0, 1, 1, 0, 1, 0, 0],
                [0, 0, 1, 0, 1, 1, 0, 0],
            ]
        )

        self.NonKeyComponent = np.asarray(
            [
                [0, 0, 0, 0, 0, 0, 1, 0],
                [0, 0, 0, 0, 0, 0, 1, 0],
                [0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 1],
                [0, 0, 0, 0, 0, 0, 1, 0],
            ]
        )

    def get_range(self):
        return np.array([self.xmin, self.xmax])

    def __call__(self, BaseStockLevel=np.ones([8]), seed=None):

        if not np.all(np.abs(np.round(BaseStockLevel) - BaseStockLevel) < 1e-5):
            raise ValueError("ATO inputs must be whole numbers!")

        self.seed += 1

        seed = seed if seed else self.seed

        fnSum = 0.0  # profit added up over simulation reps.
        np.random.seed(seed)

        SeriesLength = int(self.TotalTime * self.ArrivalRate * self.simreps * 4)

        Customer_series = np.random.choice(self.NumCustomerType, size=SeriesLength, p=self.CustomerProb)

        t = 1  # index for ticking through the customer series

        for k in range(self.simreps):  # do the simulation reps!

            EventTime = 1e5 * np.ones([1 + self.NumComponentType])
            EventTime[0] = -np.log(np.random.uniform()) * self.iArrivalRate
            TotalProfit = 0.0
            TotalCost = 0.0
            Inventory = np.ceil(BaseStockLevel)

            Clock = 0

            while Clock < self.TotalTime:

                OldInventory = Inventory
                OldClock = Clock
                Clock = np.min(EventTime)
                event = np.argmin(EventTime)

                if event == 0:
                    # a customer has come! Reset clock
                    EventTime[0] = Clock - np.log(np.random.uniform()) * self.iArrivalRate

                    # Get new customer
                    CustomerType = Customer_series[t]
                    t = t + 1

                    KeyOrder = self.KeyComponent[CustomerType,]
                    NonKeyOrder = self.NonKeyComponent[CustomerType,]

                    Sell = np.all(Inventory >= KeyOrder)

                    if Sell:
                        NonKeyOrder = Inventory * (Inventory <= NonKeyOrder) + NonKeyOrder * (Inventory > NonKeyOrder)

                        Inventory = Inventory - KeyOrder - NonKeyOrder

                        if Clock > self.WarmUp:
                            TotalProfit += np.sum(self.Profit * (KeyOrder + NonKeyOrder))

                        for i in range(self.NumComponentType):
                            if (Inventory[i] < BaseStockLevel[i]) & (EventTime[i + 1] > 1e4):
                                NewArrivalTime = self.ProTimeMean[i] + np.random.normal(1) * self.ProTimeStd[i]
                                EventTime[i + 1] = Clock + np.max([0, NewArrivalTime])

                else:
                    # stock has arrived!
                    ComponentType = event - 1
                    Inventory[ComponentType] = Inventory[ComponentType] + 1

                    if Inventory[ComponentType] >= BaseStockLevel[ComponentType]:
                        EventTime[event] = 1e5
                        if Clock > self.WarmUp:
                            TotalCost += (Clock - OldClock) * np.sum(OldInventory * self.HoldingCost)

            # end of this simulation rep, save profit
            fnSum += (TotalProfit - TotalCost) / (self.TotalTime - self.WarmUp)

        # end of all simuation reps
        fnAvg = fnSum / self.simreps

        return fnAvg


"""**New test function that can Change Simulation Parameters when required**

Changes in parameters according to

[Warm-Start Bayesian Optimization](https://arxiv.org/pdf/1608.03585.pdf)

Section 4.2
"""


class ATO_HongNelson_HotStart(ATO_HongNelson):
    def __init__(self, simreps=5):

        self.Task = 1

        ATO_HongNelson.__init__(self, simreps)

    def Next_Task(self):

        if self.Task == 1:

            self.Task = 2

            # most likely customers drop by 3% - 5%
            self.CustomerProb[0] = (0.95 + 0.02 * np.random.uniform()) * self.CustomerProb[0]
            self.CustomerProb[1] = (0.95 + 0.02 * np.random.uniform()) * self.CustomerProb[1]

            # two of remaining 3 customer are increased
            CC = np.random.choice(3, size=2, replace=False)
            self.CustomerProb[CC[0]] = (1.0 + 0.05 * np.random.uniform()) * self.CustomerProb[CC[0]]
            self.CustomerProb[CC[1]] = (1.0 + 0.05 * np.random.uniform()) * self.CustomerProb[CC[1]]

            self.CustomerProb = self.CustomerProb / np.sum(self.CustomerProb)

            # profit of some (half) items grows by 1-2 %
            CP = np.random.choice(self.NumComponentType, size=4, replace=False)
            for CPi in CP:
                self.Profit[CPi] = (1.01 + 0.01 * np.random.uniform()) * self.Profit[CPi]

        elif self.Task == 2:

            self.Task = 3

            # delivery of some (half) items is delayed
            PP = np.random.choice(self.NumComponentType, size=4, replace=False)
            for PPi in PP:
                self.ProTimeMean[PPi] = (1.0 + 0.03 * np.random.uniform()) * self.ProTimeMean[PPi]

            # all items see a higher demand, customers arrive faster
            self.ArrivalTime = 1.05 * 12.0
            self.iArrivalTime = 1 / self.ArrivalTime

            # Profits for several (half) item increase by 3-5%
            CP = np.random.choice(self.NumComponentType, size=4, replace=False)
            for CPi in CP:
                self.Profit[CPi] = (1.03 + 0.02 * np.random.uniform()) * self.Profit[CPi]

        elif self.Task == 3:

            self.Task = 4

            # Holding costs increase by 5 %
            self.HoldingCost = 1.05 * self.HoldingCost

            # Profits for several (half) item decrease by 3-5%
            CP = np.random.choice(self.NumComponentType, size=4, replace=False)
            for CPi in CP:
                self.Profit[CPi] = (0.95 + 0.02 * np.random.uniform()) * self.Profit[CPi]

        elif self.Task == 4:

            # Reinitilize the testfunction instance (go back to Task 1) keep the seed

            oldseed = self.seed

            self.__init__(self.simreps)

            self.seed = oldseed


# @title Instantiate and Call the function with random input
def main():
    f = ATO_HongNelson_HotStart()

    print("\nTestFun Initialized on Task = {}".format(f.Task))

    x_range = f.get_range()

    x = np.round(np.random.uniform(f.xmin, f.xmax))

    for i in range(8):

        print("Input = {}".format(x))
        print("Output = {}".format(f(x)))

        f.Next_Task()
        print("\nChanged to next task, Task = {}".format(f.Task))


if __name__ == "__main__":
    main()
